# NamSor API v2
#
# NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it! 
#
# The version of the OpenAPI document: 2.0.5
# Contact: contact@namsor.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Personal operations
#' @description namsor.Personal
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ Country } \emph{ [USES 10 UNITS] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } personal.name.full character
#' \item \emph{ @returnType } \link[namsor:PersonalNameGeoOut]{ PersonalNameGeoOut }   \cr
#'
#'
#' \item status code : 200 | A origined name.
#'
#' \item return type : PersonalNameGeoOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ CountryBatch } \emph{ [USES 10 UNITS] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.personal.name.in \link[namsor:BatchPersonalNameIn]{ BatchPersonalNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchPersonalNameGeoOut]{ BatchPersonalNameGeoOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchPersonalNameGeoOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Diaspora } \emph{ [USES 20 UNITS] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) }
#' 
#'
#' \itemize{
#' \item \emph{ @param } country.iso2 character
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameDiasporaedOut]{ FirstLastNameDiasporaedOut }   \cr
#'
#'
#' \item status code : 200 | A diaspora / ethnicity for given name and geography.
#'
#' \item return type : FirstLastNameDiasporaedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ DiasporaBatch } \emph{ [USES 20 UNITS] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.geo.in \link[namsor:BatchFirstLastNameGeoIn]{ BatchFirstLastNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameDiasporaedOut]{ BatchFirstLastNameDiasporaedOut }   \cr
#'
#'
#' \item status code : 200 | A list of diaspora / ethnicity given a name and residency.
#'
#' \item return type : BatchFirstLastNameDiasporaedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Gender } \emph{ Infer the likely gender of a name. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameGenderedOut]{ FirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A genderized name.
#'
#' \item return type : FirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderBatch } \emph{ Infer the likely gender of up to 100 names, detecting automatically the cultural context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.in \link[namsor:BatchFirstLastNameIn]{ BatchFirstLastNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameGenderedOut]{ BatchFirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchFirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderFull } \emph{ Infer the likely gender of a full name, ex. John H. Smith }
#' 
#'
#' \itemize{
#' \item \emph{ @param } full.name character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameGenderedOut]{ FirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A genderized name.
#'
#' \item return type : FirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderFullBatch } \emph{ Infer the likely gender of up to 100 full names, detecting automatically the cultural context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.personal.name.in \link[namsor:BatchPersonalNameIn]{ BatchPersonalNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchPersonalNameGenderedOut]{ BatchPersonalNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchPersonalNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderFullGeo } \emph{ Infer the likely gender of a full name, given a local context (ISO2 country code). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } full.name character
#' \item \emph{ @param } country.iso2 character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameGenderedOut]{ FirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A genderized name.
#'
#' \item return type : FirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderFullGeoBatch } \emph{ Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.personal.name.geo.in \link[namsor:BatchPersonalNameGeoIn]{ BatchPersonalNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchPersonalNameGenderedOut]{ BatchPersonalNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchPersonalNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderGeo } \emph{ Infer the likely gender of a name, given a local context (ISO2 country code). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @param } country.iso2 character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameGenderedOut]{ FirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A genderized name.
#'
#' \item return type : FirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GenderGeoBatch } \emph{ Infer the likely gender of up to 100 names, each given a local context (ISO2 country code). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.geo.in \link[namsor:BatchFirstLastNameGeoIn]{ BatchFirstLastNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameGenderedOut]{ BatchFirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchFirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Origin } \emph{ [USES 10 UNITS] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameOriginedOut]{ FirstLastNameOriginedOut }   \cr
#'
#'
#' \item status code : 200 | A origined name.
#'
#' \item return type : FirstLastNameOriginedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ OriginBatch } \emph{ [USES 10 UNITS] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.in \link[namsor:BatchFirstLastNameIn]{ BatchFirstLastNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameOriginedOut]{ BatchFirstLastNameOriginedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchFirstLastNameOriginedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParseName } \emph{ Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } name.full character
#' \item \emph{ @returnType } \link[namsor:PersonalNameParsedOut]{ PersonalNameParsedOut }   \cr
#'
#'
#' \item status code : 200 | A origined name.
#'
#' \item return type : PersonalNameParsedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParseNameBatch } \emph{ Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.personal.name.in \link[namsor:BatchPersonalNameIn]{ BatchPersonalNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchPersonalNameParsedOut]{ BatchPersonalNameParsedOut }   \cr
#'
#'
#' \item status code : 200 | A list of parsed names.
#'
#' \item return type : BatchPersonalNameParsedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParseNameGeo } \emph{ Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } name.full character
#' \item \emph{ @param } country.iso2 character
#' \item \emph{ @returnType } \link[namsor:PersonalNameParsedOut]{ PersonalNameParsedOut }   \cr
#'
#'
#' \item status code : 200 | A origined name.
#'
#' \item return type : PersonalNameParsedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParseNameGeoBatch } \emph{ Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.personal.name.geo.in \link[namsor:BatchPersonalNameGeoIn]{ BatchPersonalNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchPersonalNameParsedOut]{ BatchPersonalNameParsedOut }   \cr
#'
#'
#' \item status code : 200 | A list of parsed names.
#'
#' \item return type : BatchPersonalNameParsedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParsedGenderBatch } \emph{ Infer the likely gender of up to 100 fully parsed names, detecting automatically the cultural context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.parsed.full.name.in \link[namsor:BatchParsedFullNameIn]{ BatchParsedFullNameIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameGenderedOut]{ BatchFirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchFirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ParsedGenderGeoBatch } \emph{ Infer the likely gender of up to 100 fully parsed names, detecting automatically the cultural context. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.parsed.full.name.geo.in \link[namsor:BatchParsedFullNameGeoIn]{ BatchParsedFullNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameGenderedOut]{ BatchFirstLastNameGenderedOut }   \cr
#'
#'
#' \item status code : 200 | A list of genderized names.
#'
#' \item return type : BatchFirstLastNameGenderedOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UsRaceEthnicity } \emph{ [USES 10 UNITS] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameUSRaceEthnicityOut]{ FirstLastNameUSRaceEthnicityOut }   \cr
#'
#'
#' \item status code : 200 | a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#'
#' \item return type : FirstLastNameUSRaceEthnicityOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UsRaceEthnicityBatch } \emph{ [USES 10 UNITS] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.geo.in \link[namsor:BatchFirstLastNameGeoIn]{ BatchFirstLastNameGeoIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameUSRaceEthnicityOut]{ BatchFirstLastNameUSRaceEthnicityOut }   \cr
#'
#'
#' \item status code : 200 | A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#'
#' \item return type : BatchFirstLastNameUSRaceEthnicityOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UsRaceEthnicityZIP5 } \emph{ [USES 10 UNITS] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). }
#' 
#'
#' \itemize{
#' \item \emph{ @param } first.name character
#' \item \emph{ @param } last.name character
#' \item \emph{ @param } zip5.code character
#' \item \emph{ @returnType } \link[namsor:FirstLastNameUSRaceEthnicityOut]{ FirstLastNameUSRaceEthnicityOut }   \cr
#'
#'
#' \item status code : 200 | a US resident&#39;s likely race/ethnicity : W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#'
#' \item return type : FirstLastNameUSRaceEthnicityOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ UsZipRaceEthnicityBatch } \emph{ [USES 10 UNITS] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. }
#' 
#'
#' \itemize{
#' \item \emph{ @param } batch.first.last.name.geo.zipped.in \link[namsor:BatchFirstLastNameGeoZippedIn]{ BatchFirstLastNameGeoZippedIn }
#' \item \emph{ @returnType } \link[namsor:BatchFirstLastNameUSRaceEthnicityOut]{ BatchFirstLastNameUSRaceEthnicityOut }   \cr
#'
#'
#' \item status code : 200 | A list of US resident&#39;s likely race/ethnicity. W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#'
#' \item return type : BatchFirstLastNameUSRaceEthnicityOut 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 401 | Missing or incorrect API Key
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 403 | API Limit Reached or API Key Disabled
#'
#'
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \donttest{
#' ####################  Country  ####################
#'
#' library(namsor)
#' var.personal.name.full <- 'personal.name.full_example' # character | 
#'
#' #[USES 10 UNITS] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Country(var.personal.name.full)
#'
#'
#' ####################  CountryBatch  ####################
#'
#' library(namsor)
#' var.batch.personal.name.in <- BatchPersonalNameIn$new() # BatchPersonalNameIn | A list of personal names
#'
#' #[USES 10 UNITS] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$CountryBatch(batch.personal.name.in=var.batch.personal.name.in)
#'
#'
#' ####################  Diaspora  ####################
#'
#' library(namsor)
#' var.country.iso2 <- 'country.iso2_example' # character | 
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#'
#' #[USES 20 UNITS] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Diaspora(var.country.iso2, var.first.name, var.last.name)
#'
#'
#' ####################  DiasporaBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.geo.in <- BatchFirstLastNameGeoIn$new() # BatchFirstLastNameGeoIn | A list of personal names
#'
#' #[USES 20 UNITS] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$DiasporaBatch(batch.first.last.name.geo.in=var.batch.first.last.name.geo.in)
#'
#'
#' ####################  Gender  ####################
#'
#' library(namsor)
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#'
#' #Infer the likely gender of a name.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Gender(var.first.name, var.last.name)
#'
#'
#' ####################  GenderBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.in <- BatchFirstLastNameIn$new() # BatchFirstLastNameIn | A list of personal names
#'
#' #Infer the likely gender of up to 100 names, detecting automatically the cultural context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderBatch(batch.first.last.name.in=var.batch.first.last.name.in)
#'
#'
#' ####################  GenderFull  ####################
#'
#' library(namsor)
#' var.full.name <- 'full.name_example' # character | 
#'
#' #Infer the likely gender of a full name, ex. John H. Smith
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderFull(var.full.name)
#'
#'
#' ####################  GenderFullBatch  ####################
#'
#' library(namsor)
#' var.batch.personal.name.in <- BatchPersonalNameIn$new() # BatchPersonalNameIn | A list of personal names
#'
#' #Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderFullBatch(batch.personal.name.in=var.batch.personal.name.in)
#'
#'
#' ####################  GenderFullGeo  ####################
#'
#' library(namsor)
#' var.full.name <- 'full.name_example' # character | 
#' var.country.iso2 <- 'country.iso2_example' # character | 
#'
#' #Infer the likely gender of a full name, given a local context (ISO2 country code).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderFullGeo(var.full.name, var.country.iso2)
#'
#'
#' ####################  GenderFullGeoBatch  ####################
#'
#' library(namsor)
#' var.batch.personal.name.geo.in <- BatchPersonalNameGeoIn$new() # BatchPersonalNameGeoIn | A list of personal names, with a country ISO2 code
#'
#' #Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderFullGeoBatch(batch.personal.name.geo.in=var.batch.personal.name.geo.in)
#'
#'
#' ####################  GenderGeo  ####################
#'
#' library(namsor)
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#' var.country.iso2 <- 'country.iso2_example' # character | 
#'
#' #Infer the likely gender of a name, given a local context (ISO2 country code).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderGeo(var.first.name, var.last.name, var.country.iso2)
#'
#'
#' ####################  GenderGeoBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.geo.in <- BatchFirstLastNameGeoIn$new() # BatchFirstLastNameGeoIn | A list of names, with country code.
#'
#' #Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GenderGeoBatch(batch.first.last.name.geo.in=var.batch.first.last.name.geo.in)
#'
#'
#' ####################  Origin  ####################
#'
#' library(namsor)
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#'
#' #[USES 10 UNITS] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use 'diaspora' instead.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Origin(var.first.name, var.last.name)
#'
#'
#' ####################  OriginBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.in <- BatchFirstLastNameIn$new() # BatchFirstLastNameIn | A list of personal names
#'
#' #[USES 10 UNITS] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$OriginBatch(batch.first.last.name.in=var.batch.first.last.name.in)
#'
#'
#' ####################  ParseName  ####################
#'
#' library(namsor)
#' var.name.full <- 'name.full_example' # character | 
#'
#' #Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParseName(var.name.full)
#'
#'
#' ####################  ParseNameBatch  ####################
#'
#' library(namsor)
#' var.batch.personal.name.in <- BatchPersonalNameIn$new() # BatchPersonalNameIn | A list of personal names
#'
#' #Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParseNameBatch(batch.personal.name.in=var.batch.personal.name.in)
#'
#'
#' ####################  ParseNameGeo  ####################
#'
#' library(namsor)
#' var.name.full <- 'name.full_example' # character | 
#' var.country.iso2 <- 'country.iso2_example' # character | 
#'
#' #Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParseNameGeo(var.name.full, var.country.iso2)
#'
#'
#' ####################  ParseNameGeoBatch  ####################
#'
#' library(namsor)
#' var.batch.personal.name.geo.in <- BatchPersonalNameGeoIn$new() # BatchPersonalNameGeoIn | A list of personal names
#'
#' #Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParseNameGeoBatch(batch.personal.name.geo.in=var.batch.personal.name.geo.in)
#'
#'
#' ####################  ParsedGenderBatch  ####################
#'
#' library(namsor)
#' var.batch.parsed.full.name.in <- BatchParsedFullNameIn$new() # BatchParsedFullNameIn | A list of personal names
#'
#' #Infer the likely gender of up to 100 fully parsed names, detecting automatically the cultural context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParsedGenderBatch(batch.parsed.full.name.in=var.batch.parsed.full.name.in)
#'
#'
#' ####################  ParsedGenderGeoBatch  ####################
#'
#' library(namsor)
#' var.batch.parsed.full.name.geo.in <- BatchParsedFullNameGeoIn$new() # BatchParsedFullNameGeoIn | A list of personal names
#'
#' #Infer the likely gender of up to 100 fully parsed names, detecting automatically the cultural context.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$ParsedGenderGeoBatch(batch.parsed.full.name.geo.in=var.batch.parsed.full.name.geo.in)
#'
#'
#' ####################  UsRaceEthnicity  ####################
#'
#' library(namsor)
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#'
#' #[USES 10 UNITS] Infer a US resident's likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UsRaceEthnicity(var.first.name, var.last.name)
#'
#'
#' ####################  UsRaceEthnicityBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.geo.in <- BatchFirstLastNameGeoIn$new() # BatchFirstLastNameGeoIn | A list of personal names
#'
#' #[USES 10 UNITS] Infer up-to 100 US resident's likely race/ethnicity according to US Census taxonomy.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UsRaceEthnicityBatch(batch.first.last.name.geo.in=var.batch.first.last.name.geo.in)
#'
#'
#' ####################  UsRaceEthnicityZIP5  ####################
#'
#' library(namsor)
#' var.first.name <- 'first.name_example' # character | 
#' var.last.name <- 'last.name_example' # character | 
#' var.zip5.code <- 'zip5.code_example' # character | 
#'
#' #[USES 10 UNITS] Infer a US resident's likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino).
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UsRaceEthnicityZIP5(var.first.name, var.last.name, var.zip5.code)
#'
#'
#' ####################  UsZipRaceEthnicityBatch  ####################
#'
#' library(namsor)
#' var.batch.first.last.name.geo.zipped.in <- BatchFirstLastNameGeoZippedIn$new() # BatchFirstLastNameGeoZippedIn | A list of personal names
#'
#' #[USES 10 UNITS] Infer up-to 100 US resident's likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code.
#' api.instance <- PersonalApi$new()
#'
#' #Configure API key authorization: api_key
#' api.instance$apiClient$apiKeys['X-API-KEY'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$UsZipRaceEthnicityBatch(batch.first.last.name.geo.zipped.in=var.batch.first.last.name.geo.zipped.in)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom caTools base64encode
#' @export
PersonalApi <- R6::R6Class(
  'PersonalApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    Country = function(personal.name.full, ...){
      apiResponse <- self$CountryWithHttpInfo(personal.name.full, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CountryWithHttpInfo = function(personal.name.full, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`personal.name.full`)) {
        stop("Missing required parameter `personal.name.full`.")
      }

      urlPath <- "/api2/json/country/{personalNameFull}"
      if (!missing(`personal.name.full`)) {
        urlPath <- gsub(paste0("\\{", "personalNameFull", "\\}"), URLencode(as.character(`personal.name.full`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PersonalNameGeoOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    CountryBatch = function(batch.personal.name.in=NULL, ...){
      apiResponse <- self$CountryBatchWithHttpInfo(batch.personal.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    CountryBatchWithHttpInfo = function(batch.personal.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.personal.name.in`)) {
        body <- `batch.personal.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/countryBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchPersonalNameGeoOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Diaspora = function(country.iso2, first.name, last.name, ...){
      apiResponse <- self$DiasporaWithHttpInfo(country.iso2, first.name, last.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DiasporaWithHttpInfo = function(country.iso2, first.name, last.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`country.iso2`)) {
        stop("Missing required parameter `country.iso2`.")
      }

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      urlPath <- "/api2/json/diaspora/{countryIso2}/{firstName}/{lastName}"
      if (!missing(`country.iso2`)) {
        urlPath <- gsub(paste0("\\{", "countryIso2", "\\}"), URLencode(as.character(`country.iso2`), reserved = TRUE), urlPath)
      }

      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameDiasporaedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    DiasporaBatch = function(batch.first.last.name.geo.in=NULL, ...){
      apiResponse <- self$DiasporaBatchWithHttpInfo(batch.first.last.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    DiasporaBatchWithHttpInfo = function(batch.first.last.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.geo.in`)) {
        body <- `batch.first.last.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/diasporaBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameDiasporaedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Gender = function(first.name, last.name, ...){
      apiResponse <- self$GenderWithHttpInfo(first.name, last.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderWithHttpInfo = function(first.name, last.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      urlPath <- "/api2/json/gender/{firstName}/{lastName}"
      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderBatch = function(batch.first.last.name.in=NULL, ...){
      apiResponse <- self$GenderBatchWithHttpInfo(batch.first.last.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderBatchWithHttpInfo = function(batch.first.last.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.in`)) {
        body <- `batch.first.last.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/genderBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderFull = function(full.name, ...){
      apiResponse <- self$GenderFullWithHttpInfo(full.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderFullWithHttpInfo = function(full.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`full.name`)) {
        stop("Missing required parameter `full.name`.")
      }

      urlPath <- "/api2/json/genderFull/{fullName}"
      if (!missing(`full.name`)) {
        urlPath <- gsub(paste0("\\{", "fullName", "\\}"), URLencode(as.character(`full.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderFullBatch = function(batch.personal.name.in=NULL, ...){
      apiResponse <- self$GenderFullBatchWithHttpInfo(batch.personal.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderFullBatchWithHttpInfo = function(batch.personal.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.personal.name.in`)) {
        body <- `batch.personal.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/genderFullBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchPersonalNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderFullGeo = function(full.name, country.iso2, ...){
      apiResponse <- self$GenderFullGeoWithHttpInfo(full.name, country.iso2, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderFullGeoWithHttpInfo = function(full.name, country.iso2, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`full.name`)) {
        stop("Missing required parameter `full.name`.")
      }

      if (missing(`country.iso2`)) {
        stop("Missing required parameter `country.iso2`.")
      }

      urlPath <- "/api2/json/genderFullGeo/{fullName}/{countryIso2}"
      if (!missing(`full.name`)) {
        urlPath <- gsub(paste0("\\{", "fullName", "\\}"), URLencode(as.character(`full.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`country.iso2`)) {
        urlPath <- gsub(paste0("\\{", "countryIso2", "\\}"), URLencode(as.character(`country.iso2`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderFullGeoBatch = function(batch.personal.name.geo.in=NULL, ...){
      apiResponse <- self$GenderFullGeoBatchWithHttpInfo(batch.personal.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderFullGeoBatchWithHttpInfo = function(batch.personal.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.personal.name.geo.in`)) {
        body <- `batch.personal.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/genderFullGeoBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchPersonalNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderGeo = function(first.name, last.name, country.iso2, ...){
      apiResponse <- self$GenderGeoWithHttpInfo(first.name, last.name, country.iso2, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderGeoWithHttpInfo = function(first.name, last.name, country.iso2, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      if (missing(`country.iso2`)) {
        stop("Missing required parameter `country.iso2`.")
      }

      urlPath <- "/api2/json/genderGeo/{firstName}/{lastName}/{countryIso2}"
      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`country.iso2`)) {
        urlPath <- gsub(paste0("\\{", "countryIso2", "\\}"), URLencode(as.character(`country.iso2`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GenderGeoBatch = function(batch.first.last.name.geo.in=NULL, ...){
      apiResponse <- self$GenderGeoBatchWithHttpInfo(batch.first.last.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GenderGeoBatchWithHttpInfo = function(batch.first.last.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.geo.in`)) {
        body <- `batch.first.last.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/genderGeoBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Origin = function(first.name, last.name, ...){
      apiResponse <- self$OriginWithHttpInfo(first.name, last.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    OriginWithHttpInfo = function(first.name, last.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      urlPath <- "/api2/json/origin/{firstName}/{lastName}"
      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameOriginedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    OriginBatch = function(batch.first.last.name.in=NULL, ...){
      apiResponse <- self$OriginBatchWithHttpInfo(batch.first.last.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    OriginBatchWithHttpInfo = function(batch.first.last.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.in`)) {
        body <- `batch.first.last.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/originBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameOriginedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParseName = function(name.full, ...){
      apiResponse <- self$ParseNameWithHttpInfo(name.full, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParseNameWithHttpInfo = function(name.full, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`name.full`)) {
        stop("Missing required parameter `name.full`.")
      }

      urlPath <- "/api2/json/parseName/{nameFull}"
      if (!missing(`name.full`)) {
        urlPath <- gsub(paste0("\\{", "nameFull", "\\}"), URLencode(as.character(`name.full`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PersonalNameParsedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParseNameBatch = function(batch.personal.name.in=NULL, ...){
      apiResponse <- self$ParseNameBatchWithHttpInfo(batch.personal.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParseNameBatchWithHttpInfo = function(batch.personal.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.personal.name.in`)) {
        body <- `batch.personal.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/parseNameBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchPersonalNameParsedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParseNameGeo = function(name.full, country.iso2, ...){
      apiResponse <- self$ParseNameGeoWithHttpInfo(name.full, country.iso2, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParseNameGeoWithHttpInfo = function(name.full, country.iso2, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`name.full`)) {
        stop("Missing required parameter `name.full`.")
      }

      if (missing(`country.iso2`)) {
        stop("Missing required parameter `country.iso2`.")
      }

      urlPath <- "/api2/json/parseName/{nameFull}/{countryIso2}"
      if (!missing(`name.full`)) {
        urlPath <- gsub(paste0("\\{", "nameFull", "\\}"), URLencode(as.character(`name.full`), reserved = TRUE), urlPath)
      }

      if (!missing(`country.iso2`)) {
        urlPath <- gsub(paste0("\\{", "countryIso2", "\\}"), URLencode(as.character(`country.iso2`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PersonalNameParsedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParseNameGeoBatch = function(batch.personal.name.geo.in=NULL, ...){
      apiResponse <- self$ParseNameGeoBatchWithHttpInfo(batch.personal.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParseNameGeoBatchWithHttpInfo = function(batch.personal.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.personal.name.geo.in`)) {
        body <- `batch.personal.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/parseNameGeoBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchPersonalNameParsedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParsedGenderBatch = function(batch.parsed.full.name.in=NULL, ...){
      apiResponse <- self$ParsedGenderBatchWithHttpInfo(batch.parsed.full.name.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParsedGenderBatchWithHttpInfo = function(batch.parsed.full.name.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.parsed.full.name.in`)) {
        body <- `batch.parsed.full.name.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/parsedGenderBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ParsedGenderGeoBatch = function(batch.parsed.full.name.geo.in=NULL, ...){
      apiResponse <- self$ParsedGenderGeoBatchWithHttpInfo(batch.parsed.full.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ParsedGenderGeoBatchWithHttpInfo = function(batch.parsed.full.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.parsed.full.name.geo.in`)) {
        body <- `batch.parsed.full.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/parsedGenderGeoBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameGenderedOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UsRaceEthnicity = function(first.name, last.name, ...){
      apiResponse <- self$UsRaceEthnicityWithHttpInfo(first.name, last.name, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UsRaceEthnicityWithHttpInfo = function(first.name, last.name, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      urlPath <- "/api2/json/usRaceEthnicity/{firstName}/{lastName}"
      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameUSRaceEthnicityOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UsRaceEthnicityBatch = function(batch.first.last.name.geo.in=NULL, ...){
      apiResponse <- self$UsRaceEthnicityBatchWithHttpInfo(batch.first.last.name.geo.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UsRaceEthnicityBatchWithHttpInfo = function(batch.first.last.name.geo.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.geo.in`)) {
        body <- `batch.first.last.name.geo.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/usRaceEthnicityBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameUSRaceEthnicityOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UsRaceEthnicityZIP5 = function(first.name, last.name, zip5.code, ...){
      apiResponse <- self$UsRaceEthnicityZIP5WithHttpInfo(first.name, last.name, zip5.code, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UsRaceEthnicityZIP5WithHttpInfo = function(first.name, last.name, zip5.code, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`first.name`)) {
        stop("Missing required parameter `first.name`.")
      }

      if (missing(`last.name`)) {
        stop("Missing required parameter `last.name`.")
      }

      if (missing(`zip5.code`)) {
        stop("Missing required parameter `zip5.code`.")
      }

      urlPath <- "/api2/json/usRaceEthnicityZIP5/{firstName}/{lastName}/{zip5Code}"
      if (!missing(`first.name`)) {
        urlPath <- gsub(paste0("\\{", "firstName", "\\}"), URLencode(as.character(`first.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`last.name`)) {
        urlPath <- gsub(paste0("\\{", "lastName", "\\}"), URLencode(as.character(`last.name`), reserved = TRUE), urlPath)
      }

      if (!missing(`zip5.code`)) {
        urlPath <- gsub(paste0("\\{", "zip5Code", "\\}"), URLencode(as.character(`zip5.code`), reserved = TRUE), urlPath)
      }

      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "FirstLastNameUSRaceEthnicityOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    UsZipRaceEthnicityBatch = function(batch.first.last.name.geo.zipped.in=NULL, ...){
      apiResponse <- self$UsZipRaceEthnicityBatchWithHttpInfo(batch.first.last.name.geo.zipped.in, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    UsZipRaceEthnicityBatchWithHttpInfo = function(batch.first.last.name.geo.zipped.in=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (!missing(`batch.first.last.name.geo.zipped.in`)) {
        body <- `batch.first.last.name.geo.zipped.in`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/api2/json/usZipRaceEthnicityBatch"
      # API key authentication
      if ("X-API-KEY" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-API-KEY"]) > 0) {
        headerParams['X-API-KEY'] <- paste(unlist(self$apiClient$apiKeys["X-API-KEY"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "BatchFirstLastNameUSRaceEthnicityOut", "package:namsor"),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
